# 多人聊天程序 - 实验报告

## 一、程序概述

本程序是一个基于TCP流式套接字的多人聊天系统，使用C++和基本Socket API实现，支持中英文聊天。

**文件结构：**
- `protocol.h` - 聊天协议定义
- `server.cpp` - 服务器端程序
- `client.cpp` - 客户端程序
- `server.exe` - 服务器可执行文件
- `client.exe` - 客户端可执行文件

## 二、聊天协议说明

### 2.1 协议概述
本协议基于TCP流式套接字，采用自定义应用层协议，支持多客户端同时连接，由服务器转发消息。

### 2.2 消息格式
所有消息由固定头部和可变消息体组成：

```
[消息类型(1字节)] [用户名长度(1字节)] [用户名(变长)] [消息长度(2字节)] [消息内容(变长)]
```

### 2.3 消息类型定义
- `MSG_LOGIN (0x01)`: 客户端登录消息
- `MSG_LOGOUT (0x02)`: 客户端退出消息
- `MSG_CHAT (0x03)`: 普通聊天消息
- `MSG_SERVER_SHUTDOWN (0x04)`: 服务器关闭消息
- `MSG_USER_LIST (0x05)`: 在线用户列表（预留）

### 2.4 消息流程
1. 客户端连接 → 发送 `MSG_LOGIN`
2. 服务器广播新用户加入通知
3. 客户端发送聊天内容 → `MSG_CHAT`
4. 服务器转发给所有其他客户端
5. 客户端断开 → 发送 `MSG_LOGOUT` 或检测连接断开
6. 服务器关闭 → 发送 `MSG_SERVER_SHUTDOWN` 给所有客户端

### 2.5 编码
消息内容支持UTF-8编码，兼容中英文字符。

### 2.6 可靠性保证
- 基于TCP协议，保证消息顺序和可靠传输
- 通过recv/send返回值检测数据包丢失或连接断开
- 序列化/反序列化时进行边界检查

## 三、编译说明

### 3.1 Windows平台（PowerShell）

```powershell
# 编译服务器
g++ -std=c++11 -o server.exe server.cpp -lws2_32 -pthread

# 编译客户端
g++ -std=c++11 -o client.exe client.cpp -lws2_32 -pthread
```

### 3.2 Linux平台

```bash
# 编译服务器
g++ -std=c++11 -o server server.cpp -pthread

# 编译客户端
g++ -std=c++11 -o client client.cpp -pthread
```

## 四、使用说明

### 4.1 启动服务器

在PowerShell中运行：
```powershell
.\server.exe
```

服务器将在8888端口监听客户端连接。

**服务器命令：**
- 输入 `quit` - 关闭服务器，所有客户端将收到通知并自动退出

### 4.2 启动客户端

在新的PowerShell窗口中运行：
```powershell
.\client.exe
```

连接远程服务器：
```powershell
.\client.exe <服务器IP地址>
```

**客户端操作：**
1. 启动后输入用户名（1-31个字符）
2. 连接成功后即可开始聊天
3. 直接输入内容发送聊天消息
4. 输入 `/quit` - 退出聊天（其他客户端会看到退出通知）
5. 输入 `/help` - 显示帮助信息

### 4.3 退出命令与聊天内容区分

**重要：** 为了区分命令和聊天内容：
- 命令使用斜杠前缀：`/quit`、`/help`
- 聊天内容直接输入：如果想聊天说"quit"，直接输入 `quit` 即可
- 示例：
  - 输入 `quit` → 发送聊天消息"quit"
  - 输入 `/quit` → 执行退出命令

## 五、功能特性

### 5.1 多线程支持
- **服务器：** 为每个客户端创建独立处理线程，另有独立的接受连接线程
- **客户端：** 使用独立线程接收消息，主线程处理用户输入

### 5.2 多人聊天
- 支持多个客户端同时连接
- 消息实时广播给所有在线用户
- 用户加入/退出时发送通知

### 5.3 中英文支持
- UTF-8编码支持
- Windows平台自动设置控制台编码（chcp 65001）
- 可正常显示和发送中英文消息

### 5.4 正常退出机制
- 客户端输入 `/quit` 优雅退出，发送退出通知
- 服务器输入 `quit` 通知所有客户端后关闭
- 连接断开时自动清理资源
- 异常断开时检测并通知其他用户

### 5.5 对话界面
- 清晰的命令行界面
- 用户名标识发言者
- 系统消息与聊天消息区分显示
- 输入提示符 `>` 提升用户体验

## 六、测试场景

### 6.1 基本聊天测试
1. 启动服务器
2. 启动2-3个客户端，使用不同用户名
3. 在任一客户端发送消息，观察其他客户端是否收到
4. 测试中文和英文消息

### 6.2 退出测试
1. 客户端输入 `/quit`，观察：
   - 该客户端正常退出
   - 其他客户端显示"XXX 退出了聊天"
   - 服务器显示连接断开信息

2. 服务器输入 `quit`，观察：
   - 所有客户端显示"服务器已断开连接"
   - 所有客户端自动退出
   - 服务器正常关闭

### 6.3 消息区分测试
1. 客户端输入 `quit`（无斜杠）
   - 其他客户端应该看到聊天消息"quit"
   - 发送者不会退出

2. 客户端输入 `/quit`（有斜杠）
   - 发送者退出程序
   - 其他客户端看到退出通知

### 6.4 数据包丢失检测
本程序通过以下机制检测数据包丢失：
1. **TCP协议保证：** TCP本身保证数据顺序和可靠性
2. **返回值检查：** 所有send/recv调用检查返回值
3. **连接断开检测：** recv返回0或错误时判断为连接断开
4. **序列化检查：** 反序列化时进行消息格式和长度验证

**测试方法：**
- 正常使用中不会出现数据包丢失（TCP保证）
- 可通过强制关闭客户端（Ctrl+C）观察服务器检测连接断开
- 可通过关闭网络适配器模拟网络故障，观察错误处理

## 七、程序结构

### 7.1 服务器架构
```
main()
├── 初始化Winsock (Windows)
├── 创建监听套接字
├── 绑定地址和端口
├── 开始监听
├── 启动接受客户端线程
│   └── accept_clients()
│       └── 为每个客户端创建 handle_client() 线程
└── 主线程：server_command_handler() 处理服务器命令
```

### 7.2 客户端架构
```
main()
├── 初始化Winsock (Windows)
├── 输入用户名
├── 创建套接字
├── 连接服务器
├── 发送登录消息
├── 启动接收消息线程
│   └── receive_messages() 持续接收并显示消息
└── 主线程：处理用户输入和发送消息
```

### 7.3 关键数据结构
```cpp
// 消息包结构
struct ChatMessage {
    unsigned char type;              // 消息类型
    unsigned char username_len;      // 用户名长度
    char username[32];               // 用户名
    unsigned short message_len;      // 消息长度
    char message[1024];              // 消息内容
};

// 客户端信息（服务器端）
struct ClientInfo {
    SOCKET socket;                   // 套接字
    std::string username;            // 用户名
    bool active;                     // 是否活跃
};
```

## 八、代码可读性

### 8.1 代码规范
- 清晰的函数命名
- 详细的注释说明
- 合理的代码组织结构
- 跨平台兼容性处理（Windows/Linux）

### 8.2 错误处理
- 所有Socket操作检查返回值
- 异常情况输出错误信息
- 资源泄漏保护（RAII、智能指针思想）

## 九、运行示例

### 示例1：正常聊天流程
```
[服务器]
启动服务器...
用户 Alice 加入聊天
用户 Bob 加入聊天
[Alice] Hello everyone!
[Bob] Hi Alice!

[客户端1 - Alice]
请输入用户名: Alice
已连接到服务器
[系统] Bob 加入了聊天
> Hello everyone!
[Bob] Hi Alice!
> /quit

[客户端2 - Bob]
请输入用户名: Bob
已连接到服务器
[Alice] Hello everyone!
> Hi Alice!
[系统] Alice 退出了聊天
```

### 示例2：服务器关闭
```
[服务器]
服务器命令: 输入 'quit' 关闭服务器
quit
正在关闭服务器...
服务器已关闭

[客户端]
[系统] 服务器已断开连接
客户端已退出
```

## 十、实验总结

### 10.1 完成情况
- ✅ 设计并实现了完整的聊天协议
- ✅ 使用基本Socket函数（未使用封装类）
- ✅ 实现了命令行对话界面
- ✅ 支持正常退出（/quit命令和quit命令）
- ✅ 支持中英文聊天
- ✅ 采用多线程支持多人聊天
- ✅ 代码结构清晰，注释完善
- ✅ 实现了数据包丢失检测机制

### 10.2 技术要点
1. **Socket编程：** 掌握了TCP套接字的创建、绑定、监听、连接等操作
2. **多线程：** 使用C++11 std::thread实现并发处理
3. **线程同步：** 使用std::mutex保护共享数据
4. **协议设计：** 自定义应用层协议，实现消息序列化/反序列化
5. **跨平台：** 兼容Windows和Linux平台

### 10.3 数据包观察
在实验过程中：
- **正常情况：** 未观察到数据包丢失，TCP协议保证了可靠传输
- **异常情况：** 强制关闭客户端时，服务器能正确检测到连接断开
- **检测机制：** recv返回0或SOCKET_ERROR时判断为连接问题

### 10.4 改进方向
1. 增加用户认证机制
2. 支持私聊功能
3. 消息持久化存储
4. 添加心跳检测机制
5. 实现文件传输功能

---

**作者：** [你的名字]
**日期：** 2025年
**课程：** 计算机网络实验
